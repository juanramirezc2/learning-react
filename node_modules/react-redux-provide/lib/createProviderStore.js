'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getClientState = getClientState;
exports.getInitialState = getInitialState;
exports.default = createProviderStore;

var _redux = require('redux');

var _reduxReplicate = require('redux-replicate');

var _reduxReplicate2 = _interopRequireDefault(_reduxReplicate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function getClientState(_ref) {
  var providerKey = _ref.providerKey;

  if (typeof window !== 'undefined' && window.clientStates) {
    var clientState = window.clientStates[providerKey];

    if (typeof clientState !== 'undefined') {
      return clientState;
    }
  }

  return null;
}

function getInitialState(_ref2) {
  var providerKey = _ref2.providerKey;
  var state = _ref2.state;

  var clientState = getClientState({ providerKey: providerKey, state: state });

  if (clientState) {
    delete window.clientStates[providerKey];

    return state ? _extends({}, state, clientState) : clientState;
  }

  return state || {};
}

/**
 * Creates and returns a store specifically for some provider instance.
 *
 * @param {Object} providerInstance
 * @param {Mixed} storeKey Optional
 * @param {Object} createState Optional
 * @param {Function} createFunction Optional
 * @param {Object} creatorStore Optional
 * @return {Object}
 * @api public
 */
function createProviderStore(providerInstance, storeKey, createState, createFunction, creatorStore) {
  var reducers = providerInstance.reducers;
  var middleware = providerInstance.middleware;
  var enhancer = providerInstance.enhancer;
  var replication = providerInstance.replication;

  var watchedReducers = {};
  var watching = {};
  var enhancers = [];
  var create = void 0;
  var store = void 0;
  var setState = void 0;
  var settingState = void 0;
  var combinedReducers = void 0;

  if (typeof storeKey === 'undefined') {
    storeKey = providerInstance.providerKey;
  }

  function unshiftReplication(_ref3) {
    var key = _ref3.key;
    var reducerKeys = _ref3.reducerKeys;
    var queryable = _ref3.queryable;
    var baseQuery = _ref3.baseQuery;
    var replicator = _ref3.replicator;

    if (replicator) {
      if (baseQuery) {
        if (Array.isArray(reducerKeys)) {
          for (var reducerKey in baseQuery) {
            if (reducerKeys.indexOf(reducerKey) < 0) {
              reducerKeys.push(reducerKey);
            }
          }
        }

        if (Array.isArray(queryable)) {
          for (var _reducerKey in baseQuery) {
            if (queryable.indexOf(_reducerKey) < 0) {
              queryable.push(_reducerKey);
            }
          }
        }
      }

      enhancers.unshift((0, _reduxReplicate2.default)({
        key: typeof key === 'undefined' ? storeKey : key,
        reducerKeys: reducerKeys,
        queryable: queryable,
        replicator: replicator,
        create: createFunction || Boolean(createState),
        clientState: getClientState(providerInstance),
        creatorStore: creatorStore
      }));
    }
  }

  if (middleware) {
    enhancers.push(_redux.applyMiddleware.apply(null, [].concat(middleware)));
  }

  if (enhancer) {
    enhancers = enhancers.concat(enhancer);
  }

  if (replication) {
    if (Array.isArray(replication)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = replication[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value.key;

          if (typeof key !== 'undefined') {
            storeKey = key;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      replication.forEach(unshiftReplication);
    } else {
      unshiftReplication(replication);
    }
  }

  if (enhancers.length) {
    create = _redux.compose.apply(undefined, _toConsumableArray(enhancers))(_redux.createStore);
  } else {
    create = _redux.createStore;
  }

  var initialState = {};
  var preInitialState = _extends({}, createState || getInitialState(providerInstance));

  Object.keys(reducers).forEach(function (reducerKey) {
    if (typeof preInitialState[reducerKey] !== 'undefined') {
      initialState[reducerKey] = preInitialState[reducerKey];
    }

    watchedReducers[reducerKey] = function (state, action) {
      var nextState = void 0;

      if (settingState && typeof settingState[reducerKey] !== 'undefined') {
        nextState = settingState[reducerKey];
      } else {
        nextState = reducers[reducerKey](state, action);
      }

      if (watching[reducerKey] && state !== nextState) {
        watching[reducerKey].forEach(function (fn) {
          return fn(nextState);
        });
      }

      return nextState;
    };
  });

  combinedReducers = (0, _redux.combineReducers)(watchedReducers);
  store = create(combinedReducers, initialState);

  // we use a custom `watch` method with instead of a replicator
  // since it's slightly more efficient and every clock cycle counts,
  // especially with potentially thousands or even millions of components
  store.watch = function (reducerKey, fn) {
    if (!watching[reducerKey]) {
      watching[reducerKey] = new Set();
    }

    watching[reducerKey].add(fn);

    return function () {
      return watching[reducerKey].delete(fn);
    };
  };

  setState = store.setState;
  store.setState = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var nextState = args[0];

    var state = store.getState();

    if (setState) {
      var _loop = function _loop(reducerKey) {
        var current = state[reducerKey];
        var next = nextState[reducerKey];

        if (watching[reducerKey] && current !== next) {
          watching[reducerKey].forEach(function (fn) {
            return fn(next);
          });
        }
      };

      for (var reducerKey in nextState) {
        _loop(reducerKey);
      }

      setState.apply(undefined, args);
    } else {
      settingState = nextState;
      store.replaceReducer(combinedReducers);
      settingState = null;
    }
  };

  return store;
}